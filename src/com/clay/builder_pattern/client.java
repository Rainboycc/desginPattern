package com.clay.builder_pattern;

/**
 * 建造者模式
 * 优点：
 *      1、客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
 *      2、用户使用不同的具体建造者即可得到不同的产品对象。
 *      3、可以更加精细地控制产品的创建过程。
 *      4、增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。
 * 缺点：
 *      1、如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制.
 *      2、如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。
 * 适用环境：
 *      1、需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
 *      2、需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
 *      3、对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
 *      4、隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。
 * 模式应用：
 *      在很多游戏软件中，地图包括天空、地面、背景等组成部分，人物角色包括人体、服装、装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物。
 * 建造者模式的简化：
 *      1、如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。
 *      2、在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。
 * 与抽象工厂模式比较：
 *      抽象工厂模式可以看成是汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车。
 */
public class client {
    public static void main(String args[]) {
        // 抽象建造者
        MealBuilder[] mealBuilders = new MealBuilder[2];
        // 具体建造者
        mealBuilders[0] = new SubMealBuilderA();
        mealBuilders[1] = new SubMealBuilderB();
        for (int i = 0; i < mealBuilders.length; i++) {
            // 指挥者
            KFCWaiter kfcWaiter = new KFCWaiter(mealBuilders[i]);
            // 产品角色
            Meal meal = kfcWaiter.construct();
            System.out.println(meal);
        }
    }
}
